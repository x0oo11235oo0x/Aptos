// Copyright (c) Aptos
// SPDX-License-Identifier: Apache-2.0

// This file was generated. Do not modify!
//
// To update this code, run: `cargo run --release -p framework`.

// Conversion library between a structured representation of a Move script call (`ScriptCall`) and the
// standard BCS-compatible representation used in Aptos transactions (`Script`).
//
// This code was generated by compiling known Script interfaces ("ABIs") with the tool `aptos-sdk-builder`.

#![allow(dead_code)]
#![allow(unused_imports)]
use aptos_types::{
    account_address::AccountAddress,
    transaction::{EntryFunction, TransactionPayload},
};
use move_deps::move_core_types::{
    ident_str,
    language_storage::{ModuleId, TypeTag},
};

type Bytes = Vec<u8>;

/// Structured representation of a call into a known Move entry function.
/// ```ignore
/// impl EntryFunctionCall {
///     pub fn encode(self) -> TransactionPayload { .. }
///     pub fn decode(&TransactionPayload) -> Option<EntryFunctionCall> { .. }
/// }
/// ```
#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(feature = "fuzzing", derive(proptest_derive::Arbitrary))]
#[cfg_attr(feature = "fuzzing", proptest(no_params))]
pub enum EntryFunctionCall {
    /// Basic account creation methods.
    AccountCreateAccount {
        auth_key: AccountAddress,
    },

    AccountRotateAuthenticationKey {
        new_auth_key: Vec<u8>,
    },

    /// Rotates the authentication key and records a mapping on chain from the new authentication key to the originating
    /// address of the account. To authorize the rotation, a signature under the old public key on a `RotationProofChallenge`
    /// is given in `current_sig`. To ensure the account owner knows the secret key corresponding to the new public key
    /// in `new_pubkey`, a proof-of-knowledge is given in `new_sig` (i.e., a signature under the new public key on the
    /// same `RotationProofChallenge` struct).
    AccountRotateAuthenticationKeyEd25519 {
        curr_sig_bytes: Vec<u8>,
        new_sig_bytes: Vec<u8>,
        curr_pk_bytes: Vec<u8>,
        new_pk_bytes: Vec<u8>,
    },

    AccountTransfer {
        to: AccountAddress,
        amount: u64,
    },

    /// Only callable in tests and testnets where the core resources account exists.
    /// Claim the delegated mint capability and destroy the delegated token.
    AptosCoinClaimMintCapability {},

    /// Only callable in tests and testnets where the core resources account exists.
    /// Create delegated token for the address so the account could claim MintCapability later.
    AptosCoinDelegateMintCapability {
        to: AccountAddress,
    },

    /// Only callable in tests and testnets where the core resources account exists.
    /// Create new coins and deposit them into dst_addr's account.
    AptosCoinMint {
        dst_addr: AccountAddress,
        amount: u64,
    },

    /// Create a proposal with the backing `stake_pool`.
    /// @param execution_hash Required. This is the hash of the resolution script. When the proposal is resolved,
    /// only the exact script with matching hash can be successfully executed.
    AptosGovernanceCreateProposal {
        stake_pool: AccountAddress,
        execution_hash: Vec<u8>,
        metadata_location: Vec<u8>,
        metadata_hash: Vec<u8>,
    },

    /// Vote on proposal with `proposal_id` and voting power from `stake_pool`.
    AptosGovernanceVote {
        stake_pool: AccountAddress,
        proposal_id: u64,
        should_pass: bool,
    },

    /// Same as `publish_package_txn` but allows to split the metadata into multiple parts for working around
    /// size constraints.
    CodePublishPackageChunk3Txn {
        metadata_chunk1: Vec<u8>,
        metadata_chunk2: Vec<u8>,
        metadata_chunk3: Vec<u8>,
        code: Vec<Vec<u8>>,
    },

    /// Same as `publish_package` but as an entry function which can be called as a transaction. Because
    /// of current restrictions for txn parameters, the metadata needs to be passed in serialized form.
    CodePublishPackageTxn {
        metadata_serialized: Vec<u8>,
        code: Vec<Vec<u8>>,
    },

    /// Transfers `amount` of coins `CoinType` from `from` to `to`.
    CoinTransfer {
        coin_type: TypeTag,
        to: AccountAddress,
        amount: u64,
    },

    /// Upgrade total supply to use a parallelizable implementation if it is
    /// available.
    CoinUpgradeSupply {
        coin_type: TypeTag,
    },

    /// Entry function to register to receive a specific `CoinType`. An account that wants to hold a coin type
    /// has to explicitly registers to do so. The register creates a special `CoinStore`
    /// to hold the specified `CoinType`.
    CoinsRegister {
        coin_type: TypeTag,
    },

    /// This can be called by on-chain governance to update gas schedule.
    GasScheduleSetGasSchedule {
        gas_schedule_blob: Vec<u8>,
    },

    /// Withdraw an `amount` of coin `CoinType` from `account` and burn it.
    ManagedCoinBurn {
        coin_type: TypeTag,
        amount: u64,
    },

    /// Initialize new coin `CoinType` in Aptos Blockchain.
    /// Mint and Burn Capabilities will be stored under `account` in `Capabilities` resource.
    ManagedCoinInitialize {
        coin_type: TypeTag,
        name: Vec<u8>,
        symbol: Vec<u8>,
        decimals: u8,
        monitor_supply: bool,
    },

    /// Create new coins `CoinType` and deposit them into dst_addr's account.
    ManagedCoinMint {
        coin_type: TypeTag,
        dst_addr: AccountAddress,
        amount: u64,
    },

    /// Creating a resource that stores balance of `CoinType` on user's account, withdraw and deposit event handlers.
    /// Required if user wants to start accepting deposits of `CoinType` in his account.
    ManagedCoinRegister {
        coin_type: TypeTag,
    },

    /// Creates a new resource account and rotates the authentication key to either
    /// the optional auth key if it is non-empty (though auth keys are 32-bytes)
    /// or the source accounts current auth key.
    ResourceAccountCreateResourceAccount {
        seed: Vec<u8>,
        optional_auth_key: Vec<u8>,
    },

    /// Add `amount` of coins from the `account` owning the StakePool.
    StakeAddStake {
        amount: u64,
    },

    /// Similar to increase_lockup_with_cap but will use ownership capability from the signing account.
    StakeIncreaseLockup {},

    /// Initialize the validator account and give ownership to the signing account
    /// except it leaves the ValidatorConfig to be set by another entity.
    /// Note: this triggers setting the operator and owner, set it to the account's address
    /// to set later.
    StakeInitializeStakeOwner {
        initial_stake_amount: u64,
        operator: AccountAddress,
        voter: AccountAddress,
    },

    /// Initialize the validator account and give ownership to the signing account.
    StakeInitializeValidator {
        consensus_pubkey: Vec<u8>,
        proof_of_possession: Vec<u8>,
        network_addresses: Vec<u8>,
        fullnode_addresses: Vec<u8>,
    },

    /// This can only called by the operator of the validator/staking pool.
    StakeJoinValidatorSet {
        pool_address: AccountAddress,
    },

    /// Request to have `pool_address` leave the validator set. The validator is only actually removed from the set when
    /// the next epoch starts.
    /// The last validator in the set cannot leave. This is an edge case that should never happen as long as the network
    /// is still operational.
    ///
    /// Can only be called by the operator of the validator/staking pool.
    StakeLeaveValidatorSet {
        pool_address: AccountAddress,
    },

    /// Move `amount` of coins from pending_inactive to active.
    StakeReactivateStake {
        amount: u64,
    },

    /// Rotate the consensus key of the validator, it'll take effect in next epoch.
    StakeRotateConsensusKey {
        pool_address: AccountAddress,
        new_consensus_pubkey: Vec<u8>,
        proof_of_possession: Vec<u8>,
    },

    /// Allows an owner to change the delegated voter of the stake pool.
    StakeSetDelegatedVoter {
        new_delegated_voter: AccountAddress,
    },

    /// Allows an owner to change the operator of the stake pool.
    StakeSetOperator {
        new_operator: AccountAddress,
    },

    /// Similar to unlock_with_cap but will use ownership capability from the signing account.
    StakeUnlock {
        amount: u64,
    },

    /// Update the network and full node addresses of the validator. This only takes effect in the next epoch.
    StakeUpdateNetworkAndFullnodeAddresses {
        pool_address: AccountAddress,
        new_network_addresses: Vec<u8>,
        new_fullnode_addresses: Vec<u8>,
    },

    /// Withdraw from `account`'s inactive stake.
    StakeWithdraw {
        withdraw_amount: u64,
    },

    /// Updates the major version to a larger version.
    /// This can be called by on chain governance.
    VersionSetVersion {
        major: u64,
    },
}

impl EntryFunctionCall {
    /// Build an Aptos `TransactionPayload` from a structured object `EntryFunctionCall`.
    pub fn encode(self) -> TransactionPayload {
        use EntryFunctionCall::*;
        match self {
            AccountCreateAccount { auth_key } => account_create_account(auth_key),
            AccountRotateAuthenticationKey { new_auth_key } => {
                account_rotate_authentication_key(new_auth_key)
            }
            AccountRotateAuthenticationKeyEd25519 {
                curr_sig_bytes,
                new_sig_bytes,
                curr_pk_bytes,
                new_pk_bytes,
            } => account_rotate_authentication_key_ed25519(
                curr_sig_bytes,
                new_sig_bytes,
                curr_pk_bytes,
                new_pk_bytes,
            ),
            AccountTransfer { to, amount } => account_transfer(to, amount),
            AptosCoinClaimMintCapability {} => aptos_coin_claim_mint_capability(),
            AptosCoinDelegateMintCapability { to } => aptos_coin_delegate_mint_capability(to),
            AptosCoinMint { dst_addr, amount } => aptos_coin_mint(dst_addr, amount),
            AptosGovernanceCreateProposal {
                stake_pool,
                execution_hash,
                metadata_location,
                metadata_hash,
            } => aptos_governance_create_proposal(
                stake_pool,
                execution_hash,
                metadata_location,
                metadata_hash,
            ),
            AptosGovernanceVote {
                stake_pool,
                proposal_id,
                should_pass,
            } => aptos_governance_vote(stake_pool, proposal_id, should_pass),
            CodePublishPackageChunk3Txn {
                metadata_chunk1,
                metadata_chunk2,
                metadata_chunk3,
                code,
            } => code_publish_package_chunk3_txn(
                metadata_chunk1,
                metadata_chunk2,
                metadata_chunk3,
                code,
            ),
            CodePublishPackageTxn {
                metadata_serialized,
                code,
            } => code_publish_package_txn(metadata_serialized, code),
            CoinTransfer {
                coin_type,
                to,
                amount,
            } => coin_transfer(coin_type, to, amount),
            CoinUpgradeSupply { coin_type } => coin_upgrade_supply(coin_type),
            CoinsRegister { coin_type } => coins_register(coin_type),
            GasScheduleSetGasSchedule { gas_schedule_blob } => {
                gas_schedule_set_gas_schedule(gas_schedule_blob)
            }
            ManagedCoinBurn { coin_type, amount } => managed_coin_burn(coin_type, amount),
            ManagedCoinInitialize {
                coin_type,
                name,
                symbol,
                decimals,
                monitor_supply,
            } => managed_coin_initialize(coin_type, name, symbol, decimals, monitor_supply),
            ManagedCoinMint {
                coin_type,
                dst_addr,
                amount,
            } => managed_coin_mint(coin_type, dst_addr, amount),
            ManagedCoinRegister { coin_type } => managed_coin_register(coin_type),
            ResourceAccountCreateResourceAccount {
                seed,
                optional_auth_key,
            } => resource_account_create_resource_account(seed, optional_auth_key),
            StakeAddStake { amount } => stake_add_stake(amount),
            StakeIncreaseLockup {} => stake_increase_lockup(),
            StakeInitializeStakeOwner {
                initial_stake_amount,
                operator,
                voter,
            } => stake_initialize_stake_owner(initial_stake_amount, operator, voter),
            StakeInitializeValidator {
                consensus_pubkey,
                proof_of_possession,
                network_addresses,
                fullnode_addresses,
            } => stake_initialize_validator(
                consensus_pubkey,
                proof_of_possession,
                network_addresses,
                fullnode_addresses,
            ),
            StakeJoinValidatorSet { pool_address } => stake_join_validator_set(pool_address),
            StakeLeaveValidatorSet { pool_address } => stake_leave_validator_set(pool_address),
            StakeReactivateStake { amount } => stake_reactivate_stake(amount),
            StakeRotateConsensusKey {
                pool_address,
                new_consensus_pubkey,
                proof_of_possession,
            } => {
                stake_rotate_consensus_key(pool_address, new_consensus_pubkey, proof_of_possession)
            }
            StakeSetDelegatedVoter {
                new_delegated_voter,
            } => stake_set_delegated_voter(new_delegated_voter),
            StakeSetOperator { new_operator } => stake_set_operator(new_operator),
            StakeUnlock { amount } => stake_unlock(amount),
            StakeUpdateNetworkAndFullnodeAddresses {
                pool_address,
                new_network_addresses,
                new_fullnode_addresses,
            } => stake_update_network_and_fullnode_addresses(
                pool_address,
                new_network_addresses,
                new_fullnode_addresses,
            ),
            StakeWithdraw { withdraw_amount } => stake_withdraw(withdraw_amount),
            VersionSetVersion { major } => version_set_version(major),
        }
    }

    /// Try to recognize an Aptos `TransactionPayload` and convert it into a structured object `EntryFunctionCall`.
    pub fn decode(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            match SCRIPT_FUNCTION_DECODER_MAP.get(&format!(
                "{}_{}",
                script.module().name(),
                script.function()
            )) {
                Some(decoder) => decoder(payload),
                None => None,
            }
        } else {
            None
        }
    }
}

/// Basic account creation methods.
pub fn account_create_account(auth_key: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("create_account").to_owned(),
        vec![],
        vec![bcs::to_bytes(&auth_key).unwrap()],
    ))
}

pub fn account_rotate_authentication_key(new_auth_key: Vec<u8>) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("rotate_authentication_key").to_owned(),
        vec![],
        vec![bcs::to_bytes(&new_auth_key).unwrap()],
    ))
}

/// Rotates the authentication key and records a mapping on chain from the new authentication key to the originating
/// address of the account. To authorize the rotation, a signature under the old public key on a `RotationProofChallenge`
/// is given in `current_sig`. To ensure the account owner knows the secret key corresponding to the new public key
/// in `new_pubkey`, a proof-of-knowledge is given in `new_sig` (i.e., a signature under the new public key on the
/// same `RotationProofChallenge` struct).
pub fn account_rotate_authentication_key_ed25519(
    curr_sig_bytes: Vec<u8>,
    new_sig_bytes: Vec<u8>,
    curr_pk_bytes: Vec<u8>,
    new_pk_bytes: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("rotate_authentication_key_ed25519").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&curr_sig_bytes).unwrap(),
            bcs::to_bytes(&new_sig_bytes).unwrap(),
            bcs::to_bytes(&curr_pk_bytes).unwrap(),
            bcs::to_bytes(&new_pk_bytes).unwrap(),
        ],
    ))
}

pub fn account_transfer(to: AccountAddress, amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("transfer").to_owned(),
        vec![],
        vec![bcs::to_bytes(&to).unwrap(), bcs::to_bytes(&amount).unwrap()],
    ))
}

/// Only callable in tests and testnets where the core resources account exists.
/// Claim the delegated mint capability and destroy the delegated token.
pub fn aptos_coin_claim_mint_capability() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("aptos_coin").to_owned(),
        ),
        ident_str!("claim_mint_capability").to_owned(),
        vec![],
        vec![],
    ))
}

/// Only callable in tests and testnets where the core resources account exists.
/// Create delegated token for the address so the account could claim MintCapability later.
pub fn aptos_coin_delegate_mint_capability(to: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("aptos_coin").to_owned(),
        ),
        ident_str!("delegate_mint_capability").to_owned(),
        vec![],
        vec![bcs::to_bytes(&to).unwrap()],
    ))
}

/// Only callable in tests and testnets where the core resources account exists.
/// Create new coins and deposit them into dst_addr's account.
pub fn aptos_coin_mint(dst_addr: AccountAddress, amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("aptos_coin").to_owned(),
        ),
        ident_str!("mint").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&dst_addr).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
        ],
    ))
}

/// Create a proposal with the backing `stake_pool`.
/// @param execution_hash Required. This is the hash of the resolution script. When the proposal is resolved,
/// only the exact script with matching hash can be successfully executed.
pub fn aptos_governance_create_proposal(
    stake_pool: AccountAddress,
    execution_hash: Vec<u8>,
    metadata_location: Vec<u8>,
    metadata_hash: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("aptos_governance").to_owned(),
        ),
        ident_str!("create_proposal").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&stake_pool).unwrap(),
            bcs::to_bytes(&execution_hash).unwrap(),
            bcs::to_bytes(&metadata_location).unwrap(),
            bcs::to_bytes(&metadata_hash).unwrap(),
        ],
    ))
}

/// Vote on proposal with `proposal_id` and voting power from `stake_pool`.
pub fn aptos_governance_vote(
    stake_pool: AccountAddress,
    proposal_id: u64,
    should_pass: bool,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("aptos_governance").to_owned(),
        ),
        ident_str!("vote").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&stake_pool).unwrap(),
            bcs::to_bytes(&proposal_id).unwrap(),
            bcs::to_bytes(&should_pass).unwrap(),
        ],
    ))
}

/// Same as `publish_package_txn` but allows to split the metadata into multiple parts for working around
/// size constraints.
pub fn code_publish_package_chunk3_txn(
    metadata_chunk1: Vec<u8>,
    metadata_chunk2: Vec<u8>,
    metadata_chunk3: Vec<u8>,
    code: Vec<Vec<u8>>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("code").to_owned(),
        ),
        ident_str!("publish_package_chunk3_txn").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&metadata_chunk1).unwrap(),
            bcs::to_bytes(&metadata_chunk2).unwrap(),
            bcs::to_bytes(&metadata_chunk3).unwrap(),
            bcs::to_bytes(&code).unwrap(),
        ],
    ))
}

/// Same as `publish_package` but as an entry function which can be called as a transaction. Because
/// of current restrictions for txn parameters, the metadata needs to be passed in serialized form.
pub fn code_publish_package_txn(
    metadata_serialized: Vec<u8>,
    code: Vec<Vec<u8>>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("code").to_owned(),
        ),
        ident_str!("publish_package_txn").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&metadata_serialized).unwrap(),
            bcs::to_bytes(&code).unwrap(),
        ],
    ))
}

/// Transfers `amount` of coins `CoinType` from `from` to `to`.
pub fn coin_transfer(coin_type: TypeTag, to: AccountAddress, amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("coin").to_owned(),
        ),
        ident_str!("transfer").to_owned(),
        vec![coin_type],
        vec![bcs::to_bytes(&to).unwrap(), bcs::to_bytes(&amount).unwrap()],
    ))
}

/// Upgrade total supply to use a parallelizable implementation if it is
/// available.
pub fn coin_upgrade_supply(coin_type: TypeTag) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("coin").to_owned(),
        ),
        ident_str!("upgrade_supply").to_owned(),
        vec![coin_type],
        vec![],
    ))
}

/// Entry function to register to receive a specific `CoinType`. An account that wants to hold a coin type
/// has to explicitly registers to do so. The register creates a special `CoinStore`
/// to hold the specified `CoinType`.
pub fn coins_register(coin_type: TypeTag) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("coins").to_owned(),
        ),
        ident_str!("register").to_owned(),
        vec![coin_type],
        vec![],
    ))
}

/// This can be called by on-chain governance to update gas schedule.
pub fn gas_schedule_set_gas_schedule(gas_schedule_blob: Vec<u8>) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("gas_schedule").to_owned(),
        ),
        ident_str!("set_gas_schedule").to_owned(),
        vec![],
        vec![bcs::to_bytes(&gas_schedule_blob).unwrap()],
    ))
}

/// Withdraw an `amount` of coin `CoinType` from `account` and burn it.
pub fn managed_coin_burn(coin_type: TypeTag, amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("managed_coin").to_owned(),
        ),
        ident_str!("burn").to_owned(),
        vec![coin_type],
        vec![bcs::to_bytes(&amount).unwrap()],
    ))
}

/// Initialize new coin `CoinType` in Aptos Blockchain.
/// Mint and Burn Capabilities will be stored under `account` in `Capabilities` resource.
pub fn managed_coin_initialize(
    coin_type: TypeTag,
    name: Vec<u8>,
    symbol: Vec<u8>,
    decimals: u8,
    monitor_supply: bool,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("managed_coin").to_owned(),
        ),
        ident_str!("initialize").to_owned(),
        vec![coin_type],
        vec![
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&symbol).unwrap(),
            bcs::to_bytes(&decimals).unwrap(),
            bcs::to_bytes(&monitor_supply).unwrap(),
        ],
    ))
}

/// Create new coins `CoinType` and deposit them into dst_addr's account.
pub fn managed_coin_mint(
    coin_type: TypeTag,
    dst_addr: AccountAddress,
    amount: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("managed_coin").to_owned(),
        ),
        ident_str!("mint").to_owned(),
        vec![coin_type],
        vec![
            bcs::to_bytes(&dst_addr).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
        ],
    ))
}

/// Creating a resource that stores balance of `CoinType` on user's account, withdraw and deposit event handlers.
/// Required if user wants to start accepting deposits of `CoinType` in his account.
pub fn managed_coin_register(coin_type: TypeTag) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("managed_coin").to_owned(),
        ),
        ident_str!("register").to_owned(),
        vec![coin_type],
        vec![],
    ))
}

/// Creates a new resource account and rotates the authentication key to either
/// the optional auth key if it is non-empty (though auth keys are 32-bytes)
/// or the source accounts current auth key.
pub fn resource_account_create_resource_account(
    seed: Vec<u8>,
    optional_auth_key: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("resource_account").to_owned(),
        ),
        ident_str!("create_resource_account").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&seed).unwrap(),
            bcs::to_bytes(&optional_auth_key).unwrap(),
        ],
    ))
}

/// Add `amount` of coins from the `account` owning the StakePool.
pub fn stake_add_stake(amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("add_stake").to_owned(),
        vec![],
        vec![bcs::to_bytes(&amount).unwrap()],
    ))
}

/// Similar to increase_lockup_with_cap but will use ownership capability from the signing account.
pub fn stake_increase_lockup() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("increase_lockup").to_owned(),
        vec![],
        vec![],
    ))
}

/// Initialize the validator account and give ownership to the signing account
/// except it leaves the ValidatorConfig to be set by another entity.
/// Note: this triggers setting the operator and owner, set it to the account's address
/// to set later.
pub fn stake_initialize_stake_owner(
    initial_stake_amount: u64,
    operator: AccountAddress,
    voter: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("initialize_stake_owner").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&initial_stake_amount).unwrap(),
            bcs::to_bytes(&operator).unwrap(),
            bcs::to_bytes(&voter).unwrap(),
        ],
    ))
}

/// Initialize the validator account and give ownership to the signing account.
pub fn stake_initialize_validator(
    consensus_pubkey: Vec<u8>,
    proof_of_possession: Vec<u8>,
    network_addresses: Vec<u8>,
    fullnode_addresses: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("initialize_validator").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&consensus_pubkey).unwrap(),
            bcs::to_bytes(&proof_of_possession).unwrap(),
            bcs::to_bytes(&network_addresses).unwrap(),
            bcs::to_bytes(&fullnode_addresses).unwrap(),
        ],
    ))
}

/// This can only called by the operator of the validator/staking pool.
pub fn stake_join_validator_set(pool_address: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("join_validator_set").to_owned(),
        vec![],
        vec![bcs::to_bytes(&pool_address).unwrap()],
    ))
}

/// Request to have `pool_address` leave the validator set. The validator is only actually removed from the set when
/// the next epoch starts.
/// The last validator in the set cannot leave. This is an edge case that should never happen as long as the network
/// is still operational.
///
/// Can only be called by the operator of the validator/staking pool.
pub fn stake_leave_validator_set(pool_address: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("leave_validator_set").to_owned(),
        vec![],
        vec![bcs::to_bytes(&pool_address).unwrap()],
    ))
}

/// Move `amount` of coins from pending_inactive to active.
pub fn stake_reactivate_stake(amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("reactivate_stake").to_owned(),
        vec![],
        vec![bcs::to_bytes(&amount).unwrap()],
    ))
}

/// Rotate the consensus key of the validator, it'll take effect in next epoch.
pub fn stake_rotate_consensus_key(
    pool_address: AccountAddress,
    new_consensus_pubkey: Vec<u8>,
    proof_of_possession: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("rotate_consensus_key").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&pool_address).unwrap(),
            bcs::to_bytes(&new_consensus_pubkey).unwrap(),
            bcs::to_bytes(&proof_of_possession).unwrap(),
        ],
    ))
}

/// Allows an owner to change the delegated voter of the stake pool.
pub fn stake_set_delegated_voter(new_delegated_voter: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("set_delegated_voter").to_owned(),
        vec![],
        vec![bcs::to_bytes(&new_delegated_voter).unwrap()],
    ))
}

/// Allows an owner to change the operator of the stake pool.
pub fn stake_set_operator(new_operator: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("set_operator").to_owned(),
        vec![],
        vec![bcs::to_bytes(&new_operator).unwrap()],
    ))
}

/// Similar to unlock_with_cap but will use ownership capability from the signing account.
pub fn stake_unlock(amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("unlock").to_owned(),
        vec![],
        vec![bcs::to_bytes(&amount).unwrap()],
    ))
}

/// Update the network and full node addresses of the validator. This only takes effect in the next epoch.
pub fn stake_update_network_and_fullnode_addresses(
    pool_address: AccountAddress,
    new_network_addresses: Vec<u8>,
    new_fullnode_addresses: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("update_network_and_fullnode_addresses").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&pool_address).unwrap(),
            bcs::to_bytes(&new_network_addresses).unwrap(),
            bcs::to_bytes(&new_fullnode_addresses).unwrap(),
        ],
    ))
}

/// Withdraw from `account`'s inactive stake.
pub fn stake_withdraw(withdraw_amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("withdraw").to_owned(),
        vec![],
        vec![bcs::to_bytes(&withdraw_amount).unwrap()],
    ))
}

/// Updates the major version to a larger version.
/// This can be called by on chain governance.
pub fn version_set_version(major: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("version").to_owned(),
        ),
        ident_str!("set_version").to_owned(),
        vec![],
        vec![bcs::to_bytes(&major).unwrap()],
    ))
}
mod decoder {
    use super::*;
    pub fn account_create_account(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::AccountCreateAccount {
                auth_key: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn account_rotate_authentication_key(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::AccountRotateAuthenticationKey {
                new_auth_key: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn account_rotate_authentication_key_ed25519(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::AccountRotateAuthenticationKeyEd25519 {
                curr_sig_bytes: bcs::from_bytes(script.args().get(0)?).ok()?,
                new_sig_bytes: bcs::from_bytes(script.args().get(1)?).ok()?,
                curr_pk_bytes: bcs::from_bytes(script.args().get(2)?).ok()?,
                new_pk_bytes: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn account_transfer(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::AccountTransfer {
                to: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn aptos_coin_claim_mint_capability(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::AptosCoinClaimMintCapability {})
        } else {
            None
        }
    }

    pub fn aptos_coin_delegate_mint_capability(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::AptosCoinDelegateMintCapability {
                to: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn aptos_coin_mint(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::AptosCoinMint {
                dst_addr: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn aptos_governance_create_proposal(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::AptosGovernanceCreateProposal {
                stake_pool: bcs::from_bytes(script.args().get(0)?).ok()?,
                execution_hash: bcs::from_bytes(script.args().get(1)?).ok()?,
                metadata_location: bcs::from_bytes(script.args().get(2)?).ok()?,
                metadata_hash: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn aptos_governance_vote(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::AptosGovernanceVote {
                stake_pool: bcs::from_bytes(script.args().get(0)?).ok()?,
                proposal_id: bcs::from_bytes(script.args().get(1)?).ok()?,
                should_pass: bcs::from_bytes(script.args().get(2)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn code_publish_package_chunk3_txn(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CodePublishPackageChunk3Txn {
                metadata_chunk1: bcs::from_bytes(script.args().get(0)?).ok()?,
                metadata_chunk2: bcs::from_bytes(script.args().get(1)?).ok()?,
                metadata_chunk3: bcs::from_bytes(script.args().get(2)?).ok()?,
                code: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn code_publish_package_txn(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CodePublishPackageTxn {
                metadata_serialized: bcs::from_bytes(script.args().get(0)?).ok()?,
                code: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn coin_transfer(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CoinTransfer {
                coin_type: script.ty_args().get(0)?.clone(),
                to: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn coin_upgrade_supply(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CoinUpgradeSupply {
                coin_type: script.ty_args().get(0)?.clone(),
            })
        } else {
            None
        }
    }

    pub fn coins_register(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CoinsRegister {
                coin_type: script.ty_args().get(0)?.clone(),
            })
        } else {
            None
        }
    }

    pub fn gas_schedule_set_gas_schedule(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::GasScheduleSetGasSchedule {
                gas_schedule_blob: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn managed_coin_burn(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ManagedCoinBurn {
                coin_type: script.ty_args().get(0)?.clone(),
                amount: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn managed_coin_initialize(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ManagedCoinInitialize {
                coin_type: script.ty_args().get(0)?.clone(),
                name: bcs::from_bytes(script.args().get(0)?).ok()?,
                symbol: bcs::from_bytes(script.args().get(1)?).ok()?,
                decimals: bcs::from_bytes(script.args().get(2)?).ok()?,
                monitor_supply: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn managed_coin_mint(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ManagedCoinMint {
                coin_type: script.ty_args().get(0)?.clone(),
                dst_addr: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn managed_coin_register(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ManagedCoinRegister {
                coin_type: script.ty_args().get(0)?.clone(),
            })
        } else {
            None
        }
    }

    pub fn resource_account_create_resource_account(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ResourceAccountCreateResourceAccount {
                seed: bcs::from_bytes(script.args().get(0)?).ok()?,
                optional_auth_key: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn stake_add_stake(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::StakeAddStake {
                amount: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn stake_increase_lockup(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::StakeIncreaseLockup {})
        } else {
            None
        }
    }

    pub fn stake_initialize_stake_owner(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::StakeInitializeStakeOwner {
                initial_stake_amount: bcs::from_bytes(script.args().get(0)?).ok()?,
                operator: bcs::from_bytes(script.args().get(1)?).ok()?,
                voter: bcs::from_bytes(script.args().get(2)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn stake_initialize_validator(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::StakeInitializeValidator {
                consensus_pubkey: bcs::from_bytes(script.args().get(0)?).ok()?,
                proof_of_possession: bcs::from_bytes(script.args().get(1)?).ok()?,
                network_addresses: bcs::from_bytes(script.args().get(2)?).ok()?,
                fullnode_addresses: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn stake_join_validator_set(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::StakeJoinValidatorSet {
                pool_address: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn stake_leave_validator_set(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::StakeLeaveValidatorSet {
                pool_address: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn stake_reactivate_stake(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::StakeReactivateStake {
                amount: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn stake_rotate_consensus_key(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::StakeRotateConsensusKey {
                pool_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                new_consensus_pubkey: bcs::from_bytes(script.args().get(1)?).ok()?,
                proof_of_possession: bcs::from_bytes(script.args().get(2)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn stake_set_delegated_voter(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::StakeSetDelegatedVoter {
                new_delegated_voter: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn stake_set_operator(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::StakeSetOperator {
                new_operator: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn stake_unlock(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::StakeUnlock {
                amount: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn stake_update_network_and_fullnode_addresses(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::StakeUpdateNetworkAndFullnodeAddresses {
                pool_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                new_network_addresses: bcs::from_bytes(script.args().get(1)?).ok()?,
                new_fullnode_addresses: bcs::from_bytes(script.args().get(2)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn stake_withdraw(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::StakeWithdraw {
                withdraw_amount: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn version_set_version(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::VersionSetVersion {
                major: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }
}

type EntryFunctionDecoderMap = std::collections::HashMap<
    String,
    Box<
        dyn Fn(&TransactionPayload) -> Option<EntryFunctionCall>
            + std::marker::Sync
            + std::marker::Send,
    >,
>;

static SCRIPT_FUNCTION_DECODER_MAP: once_cell::sync::Lazy<EntryFunctionDecoderMap> =
    once_cell::sync::Lazy::new(|| {
        let mut map: EntryFunctionDecoderMap = std::collections::HashMap::new();
        map.insert(
            "account_create_account".to_string(),
            Box::new(decoder::account_create_account),
        );
        map.insert(
            "account_rotate_authentication_key".to_string(),
            Box::new(decoder::account_rotate_authentication_key),
        );
        map.insert(
            "account_rotate_authentication_key_ed25519".to_string(),
            Box::new(decoder::account_rotate_authentication_key_ed25519),
        );
        map.insert(
            "account_transfer".to_string(),
            Box::new(decoder::account_transfer),
        );
        map.insert(
            "aptos_coin_claim_mint_capability".to_string(),
            Box::new(decoder::aptos_coin_claim_mint_capability),
        );
        map.insert(
            "aptos_coin_delegate_mint_capability".to_string(),
            Box::new(decoder::aptos_coin_delegate_mint_capability),
        );
        map.insert(
            "aptos_coin_mint".to_string(),
            Box::new(decoder::aptos_coin_mint),
        );
        map.insert(
            "aptos_governance_create_proposal".to_string(),
            Box::new(decoder::aptos_governance_create_proposal),
        );
        map.insert(
            "aptos_governance_vote".to_string(),
            Box::new(decoder::aptos_governance_vote),
        );
        map.insert(
            "code_publish_package_chunk3_txn".to_string(),
            Box::new(decoder::code_publish_package_chunk3_txn),
        );
        map.insert(
            "code_publish_package_txn".to_string(),
            Box::new(decoder::code_publish_package_txn),
        );
        map.insert(
            "coin_transfer".to_string(),
            Box::new(decoder::coin_transfer),
        );
        map.insert(
            "coin_upgrade_supply".to_string(),
            Box::new(decoder::coin_upgrade_supply),
        );
        map.insert(
            "coins_register".to_string(),
            Box::new(decoder::coins_register),
        );
        map.insert(
            "gas_schedule_set_gas_schedule".to_string(),
            Box::new(decoder::gas_schedule_set_gas_schedule),
        );
        map.insert(
            "managed_coin_burn".to_string(),
            Box::new(decoder::managed_coin_burn),
        );
        map.insert(
            "managed_coin_initialize".to_string(),
            Box::new(decoder::managed_coin_initialize),
        );
        map.insert(
            "managed_coin_mint".to_string(),
            Box::new(decoder::managed_coin_mint),
        );
        map.insert(
            "managed_coin_register".to_string(),
            Box::new(decoder::managed_coin_register),
        );
        map.insert(
            "resource_account_create_resource_account".to_string(),
            Box::new(decoder::resource_account_create_resource_account),
        );
        map.insert(
            "stake_add_stake".to_string(),
            Box::new(decoder::stake_add_stake),
        );
        map.insert(
            "stake_increase_lockup".to_string(),
            Box::new(decoder::stake_increase_lockup),
        );
        map.insert(
            "stake_initialize_stake_owner".to_string(),
            Box::new(decoder::stake_initialize_stake_owner),
        );
        map.insert(
            "stake_initialize_validator".to_string(),
            Box::new(decoder::stake_initialize_validator),
        );
        map.insert(
            "stake_join_validator_set".to_string(),
            Box::new(decoder::stake_join_validator_set),
        );
        map.insert(
            "stake_leave_validator_set".to_string(),
            Box::new(decoder::stake_leave_validator_set),
        );
        map.insert(
            "stake_reactivate_stake".to_string(),
            Box::new(decoder::stake_reactivate_stake),
        );
        map.insert(
            "stake_rotate_consensus_key".to_string(),
            Box::new(decoder::stake_rotate_consensus_key),
        );
        map.insert(
            "stake_set_delegated_voter".to_string(),
            Box::new(decoder::stake_set_delegated_voter),
        );
        map.insert(
            "stake_set_operator".to_string(),
            Box::new(decoder::stake_set_operator),
        );
        map.insert("stake_unlock".to_string(), Box::new(decoder::stake_unlock));
        map.insert(
            "stake_update_network_and_fullnode_addresses".to_string(),
            Box::new(decoder::stake_update_network_and_fullnode_addresses),
        );
        map.insert(
            "stake_withdraw".to_string(),
            Box::new(decoder::stake_withdraw),
        );
        map.insert(
            "version_set_version".to_string(),
            Box::new(decoder::version_set_version),
        );
        map
    });
